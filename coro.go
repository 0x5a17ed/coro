// Copyright 2023 individual contributors. All rights reserved.
// Use of this source code is governed by a Zero-Clause BSD-style
// license that can be found in the LICENSE file.

package coro

import (
	"errors"
	"fmt"
	"sync/atomic"
)

type messageType int

const (
	_ messageType = iota
	messageTypeValue
	messageTypePanic
)

type (
	message[T any] struct {
		mtype messageType

		valueMessage struct {
			value T
		}

		panicMessage struct {
			value any
		}
	}
)

// ErrStopped signals to the generator that it must stop.
var ErrStopped = errors.New("stop generator")

// YieldFn is a function that is called by a generator to send back
// values generated by the same generator.
type YieldFn[I, O any] func(O) I

// GeneratorFn is a function that generates values which are sent back through
// the given [YieldFn] function.
//
// The function has a return value that will be sent back as the last
// value generated by the generator.
type GeneratorFn[I, O any] func(I, func(O) I) O

// GeneratorSub is a subroutine (a function without a return value) that
// generates values which are sent back through the given [YieldFn] function.
//
// Contrary to [GeneratorFn] the function has no return value that will
// be sent back as the last value produced by the generator.
type GeneratorSub[I, O any] func(I, func(O) I)

// C represents a coroutine encapsulating a generator that is
// executed in a goroutine.
type C[I, O any] struct {
	chInp chan message[I]
	chOut chan message[O]

	stopped atomic.Bool
}

func (cr *C[I, O]) init() {
	cr.chInp = make(chan message[I])
	cr.chOut = make(chan message[O])
}

func (cr *C[I, O]) await() (out I) {
	switch m := <-cr.chInp; m.mtype {
	case messageTypeValue:
		return m.valueMessage.value
	case messageTypePanic:
		panic(m.panicMessage.value)
	default:
		panic("unreachable")
	}
}

func (cr *C[I, O]) write(v O) {
	cr.chOut <- message[O]{
		mtype:        messageTypeValue,
		valueMessage: struct{ value O }{value: v},
	}
}

func (cr *C[I, O]) send(v O) I {
	cr.write(v)
	return cr.await()
}

func (cr *C[I, O]) run(fn func(I)) {
	defer func() {
		if !cr.stopped.Load() {
			recovered := recover()

			cr.stopped.Store(true)
			cr.chOut <- message[O]{
				mtype:        messageTypePanic,
				panicMessage: struct{ value any }{value: recovered},
			}
		}
		close(cr.chOut)
	}()

	fn(cr.await())
}

// Resume resumes the coroutine.
//
// Resume sends a given value to the encapsulated generator, causing the
// encapsulated generator to resume its operation and blocks the caller
// until the generator sends back a new value, returns or panics.
func (cr *C[I, O]) Resume(inp I) (out O, ok bool) {
	if cr.stopped.Load() {
		return
	}

	cr.chInp <- message[I]{
		mtype:        messageTypeValue,
		valueMessage: struct{ value I }{value: inp},
	}

	m, ok := <-cr.chOut
	if !ok {
		return
	}

	switch m.mtype {
	case messageTypeValue:
		return m.valueMessage.value, true
	case messageTypePanic:
		panic(m.panicMessage.value)
	default:
		panic("unreachable")
	}
}

// Stop stops the coroutine.
//
// Stop causes the encapsulated generator to panic with an [ErrStopped]
// derived value on the next invocation of [YieldFn].
//
// It is expected that the generator does not recover from the panic
// invocation and returns from its execution.
func (cr *C[I, O]) Stop() {
	if cr.stopped.Load() {
		return
	}

	err := fmt.Errorf("%w", ErrStopped)

	// Tell goroutine to panic.
	cr.chInp <- message[I]{
		mtype:        messageTypePanic,
		panicMessage: struct{ value any }{value: err},
	}
	close(cr.chInp)

	m := <-cr.chOut
	if m.mtype == messageTypePanic && m.panicMessage.value != err {
		panic(m.panicMessage.value)
	}
}

func newCoroutine[I, O any]() *C[I, O] {
	cr := &C[I, O]{}
	cr.init()
	return cr
}

// NewFn encapsulates the given [GeneratorFn] generator in a [C] coroutine.
func NewFn[I, O any](fn GeneratorFn[I, O]) *C[I, O] {
	cr := newCoroutine[I, O]()

	go cr.run(func(first I) {
		out := fn(first, cr.send)

		cr.stopped.Store(true)
		cr.write(out)
	})

	return cr
}

func PullFn[I, O any](fn GeneratorFn[I, O]) (func(I) (O, bool), func()) {
	cr := NewFn(fn)
	return cr.Resume, cr.Stop
}

// NewSub encapsulates the given [GeneratorSub] generator in a [C] coroutine.
func NewSub[I, O any](fn GeneratorSub[I, O]) *C[I, O] {
	cr := newCoroutine[I, O]()

	go cr.run(func(first I) {
		fn(first, cr.send)

		cr.stopped.Store(true)
	})

	return cr
}

func PullSub[I, O any](fn GeneratorSub[I, O]) (func(I) (O, bool), func()) {
	cr := NewSub(fn)
	return cr.Resume, cr.Stop
}
